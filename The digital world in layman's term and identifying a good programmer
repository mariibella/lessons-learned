One of the biggest lessons learned through the Digital Literacy class was that I don't have to be nervous when talking to programmers simply because I have absolutely no knowledge on how to code. There are plenty of ways to communicate with programmers as long as you have the basic understanding of how they work and know how to identify a good programmer. The following is the list of things that I will keep in mind when having to idetify a "good programmer" or having to work with one. 
Understanding the Frontend and Backend concepts and having the basic knowledge of popular software for each segment can be very helpful. I wouldn't have to know the pros and cons of every software, but I would expect the programmer to have this knowledge instead. He or she should be able to explain the pros and cons to me as the expert.
Good communication is the foundation to a successful software development. Without having to know how to code, by building user stories to understand who your customer is, the needs of the customer, and how to bridge the gap of that need (basically, laying out the role of the user, features of the software, and the benefit the software can deliver to the user) is a powerful method of providing the programmer with ideas of how the software can be built. A good programmer would generally come back with feedback or questions when in doubt which is an indication of a good communicator. The rest is really building that trust with the programmer and letting him or her use the expertise to deliver the project you want.
It was very helpful to learn that we should break the project into smaller pieces instead of using the Big Design Upfront method. In a sense, I think this is not just for software development, but a great way to do projects in general. It was good to learn that if a programmer suggests a certain amount of programming days that is completely out of your expectation, you can try to further break down the parts so the deliverable can be more manageable, and you and the programmer can work on agreeable terms. 
Finally, understanding the basic workflow (e.g. backlog, number of "work in progress"..etc) and how to manage that workflow was quite insightful. I would not have to understand the actual language to understand what the programmer has built, but at least I would know how to communicate and manage a project with the list of small deliverables.
